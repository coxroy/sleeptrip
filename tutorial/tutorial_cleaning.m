%%
%The code below provides a basic tour of data cleaning.
%Note that many functions offer additional options. Inspect individual functions for currently accepted arguments and available options.

%%
%-----general setup----
%perform basic setup of Matlab paths (only needs to be run once in a Matlab session)
st_defaults

%not all of SleepTrip's folders are added to the Matlab path to prevent potential conflicts. use "ft_hastoolbox" to add additional folders
ft_hastoolbox('external/brewermap',1,1); %add brewermap color functions

%%
%---------load data-----------
%Load one of the included mat files, containing:
% -data: ~8 h of 64-channel data sampled at 250 Hz, referenced to linked mastoids, 0.5 Hz high-pass and 50 Hz notch-filtered.
% -elec: corresponding channel locations
% -scoring: corresponding sleep scores

%It is essential that the variables 'data', 'elec', and 'scoring' match each other (which is the case for the included example data).

%select recording
useRecording='p1'; % default example
%useRecording='p2'; % second example
%useRecording='p3'; % third example (primarily used for tutorial_ICA)

prefix = fileparts(which('st_defaults'));
loadPath=fullfile(prefix,'tutorial','tutorial_data',useRecording,'data_scoring_elec.mat');
load(loadPath)

%to save space 'data' was originally saved with single precision (32 bit)
%use FieldTrip's "ft_struct2double" to convert single into double (and "ft_struct2single" for the reverse)
data=ft_struct2double(data);

%%
%-------------STEP 1: build detector set (I)---------
%The first step is to construct a detector set (collection of individual detectors).
%The simplest approach is to call "st_get_default_detector_set". This will
%return a default detector set applicable to our data properties:

%build a cfg
cfg=[];
cfg.elec=elec; %elec influences which individual detectors to include (e.g., with only 2 channels, meaningful comparisons to neigboring channels cannot be performed)
cfg.fsample=data.fsample; %fsample (sample rate) influences which individual detectors to include (considering Nyquist etc.)
cfg.include = 'default_eeg'; %this is the default for multichannel EEG (may be left out)

%get the default detector set
cfg_detector_set_default=st_get_default_detector_set(cfg);

%Note: contents of cfg.elec and cfg.fsample may override which individual detectors are returned!

%%
%-------INTERIM: inspect detector set----
%what does a detector set look like?

%inspect the contents of the default detector set...
cfg_detector_set_default %default detectors

%their names are contained in the field 'label':
cfg_detector_set_default.label

%inspect a particular detector (e.g., lowfreq)...
detector_lowfreq_ind=find(strcmp(cfg_detector_set_default.label,'lowfreq'));
cfg_detector_set_default.detectors{detector_lowfreq_ind}

%...and the individual fields inside.
cfg_detector_set_default.detectors{detector_lowfreq_ind}.ft %these are details that will be provided to FieldTrip's ft_preprocessing
cfg_detector_set_default.detectors{detector_lowfreq_ind}.st %these are details for SleepTrip

%%
%-------------build detector set (II)---------
%we can also explicitly specify which of the default detectors we want to
%include in our detector set:

cfg=[];
cfg.elec=elec;
cfg.fsample=data.fsample;
cfg.include={'highamp','jump','deviant'}; %use the names of desired detectors


cfg_detector_set_default_simple=st_get_default_detector_set(cfg)

%%
%--------------STEP 2: run artifact detection--------------------
%To perform artifact detection:
%call st_run_detector_set with 2 arguments:
%-1) a detector set cfg (as generated by st_get_default_detector_set)
%-2) data

%run all default detectors (may take a while)...
cfg_detector_set_default.scoring=scoring;
cfg_artifacts=st_run_detector_set(cfg_detector_set_default,data);

%...or uncomment below to use the smaller detector set 'cfg_detector_set_default_simple' so it runs more quickly
%cfg_detector_set_default_simple.scoring=scoring;
%cfg_artifacts=st_run_detector_set(cfg_detector_set_default_simple,data);

%%
%-----INTERIM: inspect cfg_artifacts (I)---

%complete structure
cfg_artifacts

%raw artifact information is nested inside "artifacts.raw_events"...
cfg_artifacts.artifacts.raw_events

%detected events from a particular detector are nested further...
cfg_artifacts.artifacts.raw_events.highamp

%and finally the actual start/stop times (in seconds) are contained in subfield "events":
cfg_artifacts.artifacts.raw_events.highamp.events
%%
%--------STEP 3: process raw artifacts----

%The large number of raw event start/stop times across all artifact types and channels aren't very useful by themselves.
%The function "st_process_detector_results":
% - converts the raw/continuous artifacts to a grid-like representation (channels X segments)
% - expands artifacts across time and/or space
% - labels segments for rejection and channel-segment pairs for repair
% - calculates various descriptive statistics

%we continue from cfg_artifacts (as returned by st_run_detector_set):

%example 1 - "realistic" settings
cfg_artifacts.segment_length=5; %length of segments (in sec): this is the default (may be left out)
cfg_artifacts.channelexpandthresh = 0.75; %label a segment's non-artifactual channels as artifact if at least 75% of neighboring channels are artifactual
cfg_artifacts.segmentrejectthresh=0.25; %mark segment for rejection when 25% of channels are artifactual
cfg_artifacts.badchannelthresh=0.25; % label a channel's non-artifactual segments as artifact if at least 25% of (non-rejected) segments are artifactual

%process the raw events (adds new fields):
cfg_artifacts=st_process_detector_results(cfg_artifacts);


%example 2 - "simple" settings (essentially skipping all the options):
cfg_artifacts_2=cfg_artifacts; %copy
cfg_artifacts_2.channelexpandthresh = Inf; %never expand artifacts to neighboring channels (default)
cfg_artifacts_2.segmentrejectthresh=Inf; %never mark as rejected (default)
cfg_artifacts_2.badchannelthresh=Inf; %never expand artifacts to other segments (default)

cfg_artifacts_2=st_process_detector_results(cfg_artifacts_2);

%%
%-----INTERIM: inspect cfg_artifacts (II)---
%the artifacts field now has several new fields...
cfg_artifacts.artifacts

%subfield "grid" contains various logical variables indicating yes/no presence of artifact by segment
cfg_artifacts.artifacts.grid

%subfield "grid_events" contains event start/stop times fixed to segment durations
cfg_artifacts.artifacts.grid_events

%subfield "summary" contains a table with artifact percentages by detector and sleep stage
cfg_artifacts.artifacts.summary

%%
%--------STEP 4: plot data quality----

%the function "st_plot_data_quality" provides a visual overview of where and when artifacts were detected

%we again continue from cfg_artifacts (as returned by st_process_detector_results)

%field "style" determines what kind of artifacts are shown
%cfg_artifacts.style='full'; %this is the default (may be left out): show all artifact types plus temporal/spatial expansion
%cfg_artifacts.style='basic'; %show all artifact types (without temporal/spatial expansion)
%cfg_artifacts.style='highamp'; %show a particular artifact type

%plot "realistic"
cfg_artifacts.title=['cfg_artifacts_' useRecording];%field "title" allows providing a title
st_plot_data_quality(cfg_artifacts);

%plot simple
cfg_artifacts_2.title=['cfg_artifacts_2_' useRecording];%field "title" allows providing a title
st_plot_data_quality(cfg_artifacts_2);


%%
%---------STEP 5: overlay artifacts on EEG----

%the function "st_scorebrowser" is an elaborate function for data scrolling, sleep scoring, and event visualization
%before calling it, we create an event table with the types of events we want to show, and set up some visualization options.

%1) examine the artifact types available for scorebrowser

%get the "raw" event types detected by individual detectors. these are the raw events that can start and stop at any moment in time (useful to see what was actually detected)
artifactNames_raw=fieldnames(cfg_artifacts.artifacts.raw_events)';

%get the "grid" event types from different segment-based grids (useful to see which segments are flagged)
artifactNames_grid=fieldnames(cfg_artifacts.artifacts.grid_events)';

%2) convert specified "artifacts events" to "scorebrowser events"

%provide a list (cell array) of artifact types to plot. all combinations of "raw" and "grid" events are possible.

%e.g., for raw only:
%myEventTypes=artifactNames_raw; %all the raw artifact types
%myEventTypes=artifactNames_raw(1:2);%the first two types
%myEventTypes={'deviant'}; %or written out

%e.g., for grid only:
%myEventTypes=artifactNames_grid; %all grid types (typically not very useful)
%myEventTypes={'grid_merged'};%grid showing all channel-segment pairs containing artifact of any type (= how raw artifacts "translate" to segments)
%myEventTypes={'grid_reject'};%grid of segments marked for rejection
%myEventTypes={'grid_repair'};%grid of channel-segment pairs marked for repair
%myEventTypes={'grid_reject','grid_repair'};%grid shwoing both segments marked for rejection and channel-segment pairs marked for repair

%or some combination:
myEventTypes=[artifactNames_raw 'grid_reject']; %all raw artifacts, plus segments labeled for rejection

%add desired artifact types to field "scorebrowser_events"
cfg_artifacts.scorebrowser_events=myEventTypes;

%call "st_artifacts_to_scorebrowser_events" to create an event table suitable for st_scorebrowser
eventTable=st_artifacts_to_scorebrowser_events(cfg_artifacts);

%3) customize visualization

% - each event type can be assigned a custom color and transparency
% - each event type can be highlighted as either "snake" (coloring the signal), or "box" (coloring the background)
% - because events are plotted one event type at a time (and events often overlap), plotting (and legend) order may also be set

%We'll set up the following:
% - show rejected segments (grid_reject) in red in the background using "box"
% - show all raw artifacts on top in different colors using "snake"

%a) eventLabelOrder: grid_reject followed by the rest alphabetically
sortedEvents=sort(myEventTypes);
sortedEvents(strcmp(sortedEvents,'grid_reject'))=[];
eventLabelOrder=['grid_reject' sortedEvents];

%Note: event types present in eventLabelOrder but not present in eventTable will be ignored
%Note: event types present in eventTable but not present in eventLabelOrder will be silently added to end of eventLabelOrder

%b) eventColorMapping: mapping between event types and colors


eventColsRaw=brewermap(length(eventLabelOrder)-1,'Spectral'); %use brewermap to get RGB values for distinct colors
eventColsReject=[1 0 0 ];% make rejection red
eventCols=[eventColsReject;eventColsRaw];%combine

eventColorMapping=[eventLabelOrder' num2cell(eventCols,2)]; %cell array of event types in 1st column, RGB codes in 2nd column

%Note: event types present in eventColorMapping but not present in eventTable will be ignored
%Note: event types present in eventTable but not present in eventColorMapping will be given a random color.

%c) eventHighlightMapping: mapping bewteen event types and snake/box
%although we could provide a full mapping for each event type, here's another approach:
defaultHighlighting='snake'; %standard highlighting for all event types
eventHighlightMapping={'grid_reject', 'box'}; %only set "grid_reject" to box

%Note: event types present in eventTable but not present in eventHighlightMapping will be set to default eventhighlighting.

%4) call st_scorebrowser with final cfg

%basic
cfg=[];
cfg.ylim=[-20 20]; %yrange
cfg.epochlength=30;
cfg.scoring = scoring; %add the scoring to see each epoch's sleep stage

%events
cfg.events = eventTable;
cfg.eventorder=eventLabelOrder;
cfg.eventcolormapping=eventColorMapping;
cfg.eventhighlighting=defaultHighlighting;
cfg.eventhighlightmapping=eventHighlightMapping;


%plot
st_scorebrowser(cfg, data);
%%
%------STEP 6: clean-------------
%To perform data cleaning:
%call "st_repair_artifacts" with 2 arguments:
%-1) an artifact cfg (as generated by "st_process_detector_results")
%-2) data

%In brief, cleaning proceeds by using a grid, typically "grid_repair", to determine, per segment, which channels should be cleaned.

%we can interpolate...
cfg_artifacts.gridtypeforrepair='repair_grid'; %default (may be left out)
cfg_artifacts.repairmethod='interpolate'; %default (may be left out)
data_interp=st_repair_artifacts(cfg_artifacts,data);

%..or replace with a fixed value (here: NaN, also possible to replace with zero)
cfg_artifacts.gridtypeforrepair='repair_grid'; %default (may be left out)
cfg_artifacts.repairmethod='replacewithnan'; %replace with NaN (will plot empty)
data_nan=st_repair_artifacts(cfg_artifacts,data);

%%
%---------STEP 7: visually compare pre/post-cleaning data-------

%Use the scorebrowser to inspect the data


%basic (as before)
cfg=[];
cfg.ylim=[-20 20]; %yrange
cfg.epochlength=30;
cfg.scoring = scoring; %add the scoring to see each epoch's sleep stage

%events (see step 5: here, we do everything more on the fly)
myEventTypes={'grid_reject','grid_repair'}; %event types to plot
cfg_artifacts.scorebrowser_events=myEventTypes; %assign to cfg_artifacts

cfg.events = st_artifacts_to_scorebrowser_events(cfg_artifacts); %convert to event table
cfg.eventorder=myEventTypes;
cfg.eventcolormapping=[myEventTypes' num2cell([1 0 0; 0 0 1],2)]; %set to red and blue
cfg.eventhighlighting='snake';
cfg.eventhighlightmapping={'grid_reject', 'box'};

%plot: it's possible to have multiple scorebrowsers open
st_scorebrowser(cfg, data);
st_scorebrowser(cfg, data_interp);
st_scorebrowser(cfg, data_nan);

%check e.g., epoch 181

%%
%------------STEP 8: select data and compare spectra----
% the function "st_select_data" may be used to select continuous stretches of data:
% - belonging to one or multiple sleep stages
% - with a mininmum duration (default 30 s)
% - including or excluding segments marked for rejection
% resulting data is in "trial" format, with each trial having a potentially different length

%Let's select all continuous stretches of stage N2 of at least 60 s

useStage='N2';
minDataLength=60;

% scoring_artifact_level is the original sleep scoring "resampled" to the segment length (default 5 s).
% In addition, its "excluded" field contains information on rejected segments/epochs.
scoring_artifact_level=cfg_artifacts.scoring_artifact_level;


%set up cfg for data selection
cfg_select=[];
cfg_select.scoring=scoring_artifact_level;
cfg_select.stages=useStage;
cfg_select.minlength=minDataLength;
cfg_select.makecontinuous='yes';
cfg_select.resettime='no';

%---create 3 data versions:-----
%1) raw stage data
cfg_select.usescoringexclusion='no'; %do not consider the information in the "excluded" field (i.e., rejected segments are included)
stage_data_incRej_incArt=st_select_data(cfg_select, data); %raw data

%2) raw stage data, minus rejected
cfg_select.usescoringexclusion='yes'; % do consider the information in the "excluded" field (i.e., skip rejected data)
stage_data_excRej_incArt=st_select_data(cfg_select, data); %raw data

%3) cleaned (interpolated) stage data, minus rejected
cfg_select.usescoringexclusion='yes';
stage_data_excRej_excArt=st_select_data(cfg_select, data_interp); %cleaned data

%combine data versions and create labels
stage_data_verions={stage_data_incRej_incArt,stage_data_excRej_incArt,stage_data_excRej_excArt};
dataLabels={'raw','segment-rejected','segment-rejected + channel-interpolated'};

%---identify channels for plotting---
%some work to identify best/worst 2 channels in terms of artifact in stage of interest
numCh=2;
artifact_grid=cfg_artifacts.artifacts.grid.artifact_grid_merged;
artifact_grid_stage=mean(artifact_grid(:,strcmp(scoring_artifact_level.epochs,useStage)),2);
[artifact_prop,sort_idx]=sort(artifact_grid_stage);
channels_of_interest=data.label(sort_idx([1:numCh, end-numCh+1:end]));

%get blue and red colors
plotCols=flipud(brewermap((numCh*2)+2,'RdYlBu'));
plotCols=plotCols([1:numCh end-numCh+1:end],:);


%---run spectral analyses--

%intialize a cfg for "st_welch"
cfg_welch=[];
cfg_welch.method='psd';
cfg_welch.channel = channels_of_interest;



figure('Position', [1000 120.5000 1300 300])

for data_ver_i=1:length(stage_data_verions)

    %call "st_welch" for current dataset
    freq_data=st_welch(cfg_welch,stage_data_verions{data_ver_i});


    subplot(1,3,data_ver_i)

    %plot
    plot(freq_data.freq,log10(freq_data.powspctrm),'LineWidth',1.5)
    set(gca,'XScale','lin','xlim',[0 30],'ColorOrder',plotCols)
    title(sprintf('%s',dataLabels{data_ver_i}))

    if data_ver_i==1
        legend(cfg_welch.channel)
        ylabel('log10(PSD) (\muV^2/Hz)')

        xlabel('frequency (Hz)')
    end

end


%--some plotting niceties--
%background color
fh=gcf;
set(fh,'color','w')
%set all y limits the same
allAxesInFigure = findall(fh,'type','axes');
ylims_old=cell2mat(get(allAxesInFigure,'yLim'));
set(allAxesInFigure,'yLim',[min(ylims_old(:,1)) max(ylims_old(:,2))])
%overall title
sgtitle(useStage)
